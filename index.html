<!DOCTYPE html>
<!-- Made by your friend, Kevin  -->
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kevin's Quick View </title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/material-darker.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/properties/properties.min.js"></script>
  <style>
    :root {
      --bg: #424141;
      --panel: #343434;
      --panel-2: #242424;
      --muted: #676767;
      --text: #F7F7F7;
      --brand: #00693E;
      --brand-2: #12312B;
      --ok: #4caf50;
      --warn: #FFA00F;
      --err: #9D162E;
    }
    html, body { height: 100%; }
    body { margin: 0; background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; overflow: hidden; }
    .container { display: grid; grid-template-columns: 42% 58%; height: 100vh; }
    .input-panel { border-right: 1px solid #303030; display: grid; grid-template-rows: auto 1fr auto auto; background: var(--panel); }
    .viewer-panel { position: relative; background: var(--bg); }
    .header { background: var(--brand); padding: 12px 16px; font-weight: 700; letter-spacing: .2px; }
    .subheader { display:flex; gap:8px; align-items:center; padding: 8px 12px; background: var(--panel-2); border-bottom:1px solid #303030; flex-wrap: wrap; }
    .subheader select, .subheader input[type="range"], .subheader button { background:#1a1a1a; border:1px solid #333; color:var(--text); border-radius:6px; padding:6px 10px; font-size:12px; }
    .editor { height: 100%; }
    .controls { padding: 10px 12px; background: var(--panel-2); border-top: 1px solid #303030; display:flex; flex-wrap:wrap; gap:8px; }
    .btn { background: var(--brand); border: none; color: #fff; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-weight:600; font-size: 12px; }
    .btn.secondary { background: #2d2d2d; border:1px solid #3a3a3a; color:#ddd; }
    .btn:hover { background: var(--brand-2); }
    .btn.secondary:hover { background: #3a3a3a; }
    .warnings-panel { padding: 10px 12px; background: var(--panel); border-top: 1px solid #303030; max-height: 180px; overflow: auto; }
    .pill { display:inline-flex; align-items:center; gap:8px; font-size:12px; font-weight:600; padding: 6px 10px; border-radius: 999px; margin: 4px 6px 0 0; }
    .ok { background: rgba(76,175,80,.15); color: #8be28b; border:1px solid rgba(76,175,80,.35); }
    .warn { background: rgba(255,152,0,.15); color: #ffbd5a; border:1px solid rgba(255,152,0,.35); }
    .err { background: rgba(244,67,54,.15); color: #ff8a80; border:1px solid rgba(244,67,54,.35); }
    .logline { font-size: 12px; margin:6px 0; padding:6px 8px; border-radius:6px; border:1px solid #333; background:#171717; }
    .viewer-controls { position: absolute; top: 10px; right: 10px; display:flex; flex-direction:column; gap:6px; z-index:10; }
    .viewer-controls .btn { padding:6px 10px; font-size:12px; }
    #viewer { width:100%; height:100%; display:block; }
    .legend { position:absolute; bottom:10px; right:10px; background:rgba(0,0,0,0.7); backdrop-filter: blur(3px); border:1px solid #333; border-radius:8px; padding:8px 10px; font-size:11px; }
    .badge { display:inline-block; padding:2px 6px; font-size:10px; border-radius:999px; border:1px solid #333; background:#151515; color:#bbb; }
    .cm-error-line { background: rgba(244,67,54,.15) !important; }
  </style>
</head>
<body>
  <div class="container">
   <div class="input-panel" style="display: flex; flex-direction: column; height: 100vh;">
  <div class="header" style="background: #00693E;">Kevin's Quick View for TOPAS MC</div>
  <div class="subheader" style="height: 120px; overflow:hidden">
        <button class="btn" id="btnUpdate">Update Geometry</button>
        <button class="btn secondary" id="btnFit">Fit to View</button>
        <button class="btn secondary" id="btnReset">Reset Camera</button>
        <button class="btn secondary" id="btnWire">Wireframe</button>
        <button class="btn secondary" id="btnAxes">Axes</button>
        <label class="badge">Opacity <input id="opacity" type="range" min="0.05" max="1" step="0.05" value="0.7" style="accent-color: #12312B;" /></label>
      </div>
       <div class="editor" id="editor" style="flex: 1; min-height: 0; height: 100%;"></div>
  <div class="controls">
        <span class="badge">Views:</span>
        <button class="btn secondary" data-view="iso">Isometric</button>
        <button class="btn secondary" data-view="top">Top</button>
        <button class="btn secondary" data-view="front">Front</button>
        <button class="btn secondary" data-view="right">Right</button>
     </div>
 <div class="warnings-panel" id="warnings" style="flex-shrink: 0; max-height: 200px; overflow: auto;"></div>
</div>
    
    <div class="viewer-panel">
		  <div style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 10; padding: 8px 16px; border-radius: 4px; font-size: 12px; text-align: center; line-height: 1.4;">
    Kevin Willy, Dartmouth College
  </div>
      <canvas id="viewer"></canvas>
      <div class="legend">Scroll: zoom • Drag: orbit • Right-drag: pan</div>
    </div>
  </div>

  <script>
    let scene, camera, renderer, controls, axesHelper;
    let geometryGroup = new THREE.Group();
    let wireframeMode = false; 
    let showAxes = true;

    class SimpleOrbitControls {
      constructor(camera, domElement) {
        this.camera = camera;
        this.domElement = domElement;
        this.target = new THREE.Vector3();
        this.enabled = true;
        this.rotateSpeed = 1.0;
        this.zoomSpeed = 1.0;
        this.panSpeed = 1.0;
        this.minDistance = 0;
        this.maxDistance = Infinity;
        this.spherical = new THREE.Spherical();
        this.sphericalDelta = new THREE.Spherical();
        this.scale = 1;
        this.panOffset = new THREE.Vector3();
        this.rotateStart = new THREE.Vector2();
        this.rotateEnd = new THREE.Vector2();
        this.rotateDelta = new THREE.Vector2();
        this.panStart = new THREE.Vector2();
        this.panEnd = new THREE.Vector2();
        this.panDelta = new THREE.Vector2();
        this.zoomStart = new THREE.Vector2();
        this.zoomEnd = new THREE.Vector2();
        this.zoomDelta = new THREE.Vector2();
        this.state = 'NONE';
        this.setupEventListeners();
        this.update();
      }
      
      setupEventListeners() {
        this.domElement.addEventListener('mousedown', this.onMouseDown.bind(this));
        this.domElement.addEventListener('wheel', this.onMouseWheel.bind(this));
        this.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
        document.addEventListener('mousemove', this.onMouseMove.bind(this));
        document.addEventListener('mouseup', this.onMouseUp.bind(this));
      }
      
      onMouseDown(event) {
        if (!this.enabled) return;
        event.preventDefault();
        if (event.button === 0) {
          this.state = 'ROTATE';
          this.rotateStart.set(event.clientX, event.clientY);
        } else if (event.button === 2) {
          this.state = 'PAN';
          this.panStart.set(event.clientX, event.clientY);
        }
      }
      
      onMouseMove(event) {
        if (!this.enabled) return;
        event.preventDefault();
        if (this.state === 'ROTATE') {
          this.rotateEnd.set(event.clientX, event.clientY);
          this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart).multiplyScalar(this.rotateSpeed);
          this.rotateLeft(2 * Math.PI * this.rotateDelta.x / this.domElement.clientWidth);
          this.rotateUp(2 * Math.PI * this.rotateDelta.y / this.domElement.clientHeight);
          this.rotateStart.copy(this.rotateEnd);
          this.update();
        } else if (this.state === 'PAN') {
          this.panEnd.set(event.clientX, event.clientY);
          this.panDelta.subVectors(this.panEnd, this.panStart).multiplyScalar(this.panSpeed);
          this.pan(this.panDelta.x, this.panDelta.y);
          this.panStart.copy(this.panEnd);
          this.update();
        }
      }
      
      onMouseUp(event) {
        if (!this.enabled) return;
        this.state = 'NONE';
      }
      
      onMouseWheel(event) {
        if (!this.enabled) return;
        event.preventDefault();
        if (event.deltaY < 0) {
          this.dollyIn(this.getZoomScale());
        } else {
          this.dollyOut(this.getZoomScale());
        }
        this.update();
      }
      
      rotateLeft(angle) { this.sphericalDelta.theta -= angle; }
      rotateUp(angle) { this.sphericalDelta.phi -= angle; }
      
      pan(deltaX, deltaY) {
        const offset = new THREE.Vector3();
        const position = this.camera.position;
        offset.copy(position).sub(this.target);
        let targetDistance = offset.length();
        targetDistance *= Math.tan((this.camera.fov / 2) * Math.PI / 180.0);
        this.panLeft(2 * deltaX * targetDistance / this.domElement.clientHeight, this.camera.matrix);
        this.panUp(2 * deltaY * targetDistance / this.domElement.clientHeight, this.camera.matrix);
      }
      
      panLeft(distance, objectMatrix) {
        const v = new THREE.Vector3();
        v.setFromMatrixColumn(objectMatrix, 0);
        v.multiplyScalar(-distance);
        this.panOffset.add(v);
      }
      
      panUp(distance, objectMatrix) {
        const v = new THREE.Vector3();
        v.setFromMatrixColumn(objectMatrix, 1);
        v.multiplyScalar(distance);
        this.panOffset.add(v);
      }
      
      dollyIn(dollyScale) { this.scale /= dollyScale; }
      dollyOut(dollyScale) { this.scale *= dollyScale; }
      getZoomScale() { return Math.pow(0.95, this.zoomSpeed); }
      
      update() {
        const offset = new THREE.Vector3();
        const quat = new THREE.Quaternion().setFromUnitVectors(this.camera.up, new THREE.Vector3(0, 1, 0));
        const quatInverse = quat.clone().conjugate();
        const position = this.camera.position;
        offset.copy(position).sub(this.target);
        offset.applyQuaternion(quat);
        this.spherical.setFromVector3(offset);
        this.spherical.theta += this.sphericalDelta.theta;
        this.spherical.phi += this.sphericalDelta.phi;
        this.spherical.phi = Math.max(0.000001, Math.min(Math.PI - 0.000001, this.spherical.phi));
        this.spherical.radius *= this.scale;
        this.spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, this.spherical.radius));
        this.target.add(this.panOffset);
        offset.setFromSpherical(this.spherical);
        offset.applyQuaternion(quatInverse);
        position.copy(this.target).add(offset);
        this.camera.lookAt(this.target);
        this.sphericalDelta.set(0, 0, 0);
        this.scale = 1;
        this.panOffset.set(0, 0, 0);
        return true;
      }
    }

    function initThree() {
      const canvas = document.getElementById('viewer');
      const rect = canvas.getBoundingClientRect();
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x121212);
      camera = new THREE.PerspectiveCamera(60, rect.width/rect.height, 0.1, 50000);
      camera.position.set(300, 240, 300);
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(rect.width, rect.height);
      const amb = new THREE.AmbientLight(0xffffff, 0.6); 
      scene.add(amb);
      const dir = new THREE.DirectionalLight(0xffffff, 0.7); 
      dir.position.set(200,200,100); 
      scene.add(dir);
      controls = new SimpleOrbitControls(camera, canvas);
      axesHelper = new THREE.AxesHelper(100);
      axesHelper.visible = showAxes;
      scene.add(axesHelper);
      scene.add(geometryGroup);
      window.addEventListener('resize', onResize);
      animate();
    }
    
    function onResize(){
      const canvas = document.getElementById('viewer');
      const rect = canvas.getBoundingClientRect();
      camera.aspect = rect.width/rect.height; 
      camera.updateProjectionMatrix();
      renderer.setSize(rect.width, rect.height);
    }
    
    function animate(){
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    let editor, errorMarks = [];
    
    function initEditor(){
      const editorElement = document.getElementById('editor');
      editor = CodeMirror(editorElement, {
        value: `# Parent-Daughter Geometry Example
s:Ge/World/Type = "TsBox"
d:Ge/World/HLX = 50 cm
d:Ge/World/HLY = 50 cm
d:Ge/World/HLZ = 50 cm
s:Ge/World/Material = "Air"

# Large box (parent)
s:Ge/Box1/Type = "TsBox"
s:Ge/Box1/Parent = "World"
d:Ge/Box1/HLX = 20 cm
d:Ge/Box1/HLY = 20 cm
d:Ge/Box1/HLZ = 20 cm
d:Ge/Box1/TransX = -20 cm
s:Ge/Box1/Material = "Water"

# Daughter box cuts into parent
s:Ge/CutBox/Type = "TsBox"
s:Ge/CutBox/Parent = "Box1"
d:Ge/CutBox/HLX = 8 cm
d:Ge/CutBox/HLY = 8 cm
d:Ge/CutBox/HLZ = 8 cm
d:Ge/CutBox/TransX = 0 cm
s:Ge/CutBox/Material = "Air"

# Hollow Cylinder (parent)
s:Ge/HollowCyl/Type = "TsCylinder"
s:Ge/HollowCyl/Parent = "World"
d:Ge/HollowCyl/RMin = 63.9 mm
d:Ge/HollowCyl/RMax = 88.9 mm
d:Ge/HollowCyl/HL = 84.15 mm
d:Ge/HollowCyl/TransZ = 88.75 mm
s:Ge/HollowCyl/Material = "Lead"

# Daughter sphere inside hollow cylinder
s:Ge/SphereInCyl/Type = "TsSphere"
s:Ge/SphereInCyl/Parent = "HollowCyl"
d:Ge/SphereInCyl/RMax = 50 mm
d:Ge/SphereInCyl/TransZ = 0 cm
s:Ge/SphereInCyl/Material = "Copper"

# Multi-level: grand-daughter cuts into daughter
s:Ge/InnerBox/Type = "TsBox"
s:Ge/InnerBox/Parent = "CutBox"
d:Ge/InnerBox/HLX = 3 cm
d:Ge/InnerBox/HLY = 3 cm
d:Ge/InnerBox/HLZ = 3 cm
d:Ge/InnerBox/TransX = 0 cm
s:Ge/InnerBox/Material = "Aluminum"
`,
        mode: 'properties',
        theme: 'material-darker',
        lineNumbers: true,
        autofocus: true,
        tabSize: 2,
        indentUnit: 2,
      });
		  const cmWrapper = editorElement.querySelector('.CodeMirror');
  if (cmWrapper) {
    cmWrapper.style.height = '100%';
  }
      editor.on('change', debounce(updateGeometry, 600));
    }

    function colorNameToHex(colorName) {
      const colorMap = {
        // Basic colors
        'white': 0xffffff, 'black': 0x000000,
        'red': 0xff0000, 'green': 0x00ff00, 'blue': 0x0000ff,
        'yellow': 0xffff00, 'cyan': 0x00ffff, 'magenta': 0xff00ff,
        'orange': 0xff8800, 'purple': 0x800080, 'pink': 0xffc0cb,
        'brown': 0x8b4513, 'gray': 0x808080, 'grey': 0x808080,
        
        // Extended colors
        'lightblue': 0xadd8e6, 'darkblue': 0x00008b,
        'lightgreen': 0x90ee90, 'darkgreen': 0x006400,
        'lightgray': 0xd3d3d3, 'darkgray': 0xa9a9a9,
        'lightyellow': 0xffffe0, 'gold': 0xffd700,
        'silver': 0xc0c0c0, 'bronze': 0xcd7f32,
        'violet': 0xee82ee, 'indigo': 0x4b0082,
        'turquoise': 0x40e0d0, 'lime': 0x00ff00,
        'olive': 0x808000, 'navy': 0x000080,
        'teal': 0x008080, 'maroon': 0x800000,
        'skyblue': 0x87ceeb, 'grass': 0x7cfc00
      };
      
      const name = colorName.toLowerCase().trim();
      return colorMap[name] !== undefined ? colorMap[name] : 0xffffff;
    }

    const materials = {
      'Air': { color: 0x87ceeb, opacity: 0.15 },
      'Water': { color: 0x4169e1, opacity: 0.55 },
      'Aluminum': { color: 0xc0c0c0, opacity: 0.8 },
      'Lead': { color: 0x2f2f2f, opacity: 0.9 },
      'Copper': { color: 0xb87333, opacity: 0.8 },
      'Steel': { color: 0x708090, opacity: 0.8 },
      'Default': { color: 0xffffff, opacity: 0.7 }
    };

    let parsedGeometry = {};
    let nameToLine = {};
    let currentOpacity = 0.7;

    function parseTopasGeometry(text){
      const lines = text.split(/\r?\n/);
      const geometry = {}; 
      const warnings = []; 
      const errors = [];
      nameToLine = {};

      for (let i=0;i<lines.length;i++){
        const line = lines[i].trim();
        if (!line || line.startsWith('#') || line.startsWith('//')) continue;
        
        const m = line.match(/([sdbSDB]):Ge\/([^\/]+)\/([^=]+)\s*=\s*(.+)/);
        if (!m) continue;
        
        const [, type, component, propertyRaw, valueRaw] = m;
        if (!geometry[component]) geometry[component] = {};
        nameToLine[component] = i+1;

        const prop = normalizeProp(propertyRaw);
        let val;
        
        try{
          if (type.toLowerCase()==='s'){
            val = valueRaw.replace(/["']/g,'');
            if (prop==='Type') val = normalizeType(val);
          } else if (type.toLowerCase()==='d'){
            val = parseWithUnits(valueRaw);
          } else if (type.toLowerCase()==='b'){
            val = /true/i.test(valueRaw);
          }
        }catch(e){ 
          errors.push(`Line ${i+1}: ${e.message}`); 
        }
        
        geometry[component][prop] = val;
      }

      validateGeometry(geometry, warnings, errors);
      return { geometry, warnings, errors };
    }

    function normalizeProp(p){
      const key = p.trim();
      const map = { 
        type:'Type', parent:'Parent', material:'Material', color:'Color',
        rmax:'RMax', rmin:'RMin', hlx:'HLX', hly:'HLY', hlz:'HLZ', hl:'HL', 
        rx:'Rx', ry:'Ry', rz:'Rz', rtor:'Rtor',
        rmax1:'RMax1', rmin1:'RMin1', rmax2:'RMax2', rmin2:'RMin2',
        transx:'TransX', transy:'TransY', transz:'TransZ', 
        rotx:'RotX', roty:'RotY', rotz:'RotZ' 
      };
      const l = key.toLowerCase();
      return map[l] || key.replace(/\s+/g,'');
    }

    function normalizeType(t){
      const l = t.toLowerCase();
      const map = { 
        tsbox:'TsBox', tssphere:'TsSphere', tscylinder:'TsCylinder', 
        tstube:'TsTube', tstubs:'TsTubs', tscone:'TsCone', tstorus:'TsTorus',
        tsellipsoid:'TsEllipsoid', tsellipticaltube:'TsEllipticalTube',
        tstrap:'TsTrap', tstrd:'TsTrd', tspara:'TsPara', tswedge:'TsWedge',
      };
      return map[l] || t;
    }

    function parseWithUnits(expr){
      const m = String(expr).trim().match(/([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)\s*(\w+)?/);
      if(!m) throw new Error(`Cannot parse value '${expr}'`);
      
      let num = parseFloat(m[1]);
      const unit = (m[2]||'mm').toLowerCase();
      
      if (unit==='cm') num *= 10; 
      else if (unit==='m') num *= 1000; 
      else if (unit==='mm') num *= 1; 
      else if (unit==='deg' || unit==='degree' || unit==='degrees') num = THREE.MathUtils.degToRad(num);
      
      return num;
    }

    function validateGeometry(geom, warnings, errors){
      for (const [name, p] of Object.entries(geom)){
        if (!p.Type){ 
          errors.push(`${name}: Missing Type`); 
          continue; 
        }
        
        switch (p.Type){
          case 'TsBox':
            ['HLX','HLY','HLZ'].forEach(dim=>{
              if(!p[dim]) errors.push(`${name}: Missing ${dim}`); 
              else if (p[dim]<=0) errors.push(`${name}: ${dim} must be > 0`); 
            });
            break;
          case 'TsCylinder':
            if (!p.RMax) errors.push(`${name}: Missing RMax`); 
            if (!p.HL) errors.push(`${name}: Missing HL`);
            break;
          case 'TsSphere':
            if (!p.RMax) errors.push(`${name}: Missing RMax`);
            break;
        }
        
        if (p.Parent && !geom[p.Parent]) {
          errors.push(`${name}: Parent '${p.Parent}' not found`);
        }
      }
    }
    
    function getChildrenOf(name, geom) {
      return Object.keys(geom).filter(key => geom[key].Parent === name);
    }
    
    function isInsideHollowCylinder(childGeom, cylinderGeom, childPos, cylPos) {
      // Check if child is inside the hollow cavity of a cylinder
      if (cylinderGeom.Type !== 'TsCylinder' || !cylinderGeom.RMin || cylinderGeom.RMin <= 0) {
        return false;
      }
      
      // Get relative position of child to cylinder
      const relX = childPos.x - cylPos.x;
      const relY = childPos.y - cylPos.y;
      const relZ = childPos.z - cylPos.z;
      
      // Calculate radial distance from cylinder axis (Z-axis)
      const radialDist = Math.sqrt(relX * relX + relY * relY);
      
      // Check Z bounds
      const cylHL = cylinderGeom.HL || 0;
      if (Math.abs(relZ) > cylHL) {
        return false;
      }
      
      // Check if child is within the inner radius
      let childRadius = 0;
      if (childGeom.Type === 'TsCylinder') {
        childRadius = childGeom.RMax || 0;
      } else if (childGeom.Type === 'TsSphere') {
        childRadius = childGeom.RMax || 0;
      } else if (childGeom.Type === 'TsBox') {
        childRadius = Math.max(childGeom.HLX || 0, childGeom.HLY || 0);
      }
      
      return (radialDist + childRadius) <= cylinderGeom.RMin;
    }

    function checkHierarchyOverlaps(geom, meshes, warnings) {
      const allNames = Object.keys(geom);
      
      for (const parent of allNames) {
        const children = getChildrenOf(parent, geom);
        
        for (let i = 0; i < children.length; i++) {
          for (let j = i + 1; j < children.length; j++) {
            const child1Name = children[i];
            const child2Name = children[j];
            const child1Geom = geom[child1Name];
            const child2Geom = geom[child2Name];
            
            if (meshes[child1Name] && meshes[child2Name]) {
              const box1 = new THREE.Box3().setFromObject(meshes[child1Name]);
              const box2 = new THREE.Box3().setFromObject(meshes[child2Name]);
              
              if (box1.intersectsBox(box2)) {
                // Check if one is inside the other's hollow cavity
                const pos1 = { x: child1Geom.TransX || 0, y: child1Geom.TransY || 0, z: child1Geom.TransZ || 0 };
                const pos2 = { x: child2Geom.TransX || 0, y: child2Geom.TransY || 0, z: child2Geom.TransZ || 0 };
                
                const child2InChild1Cavity = isInsideHollowCylinder(child2Geom, child1Geom, pos2, pos1);
                const child1InChild2Cavity = isInsideHollowCylinder(child1Geom, child2Geom, pos1, pos2);
                
                if (!child2InChild1Cavity && !child1InChild2Cavity) {
                  warnings.push(`Overlap: '${child1Name}' and '${child2Name}' (siblings under '${parent}')`);
                }
              }
            }
          }
        }
      }
    }

    function createHollowCylinderGeometry(rMin, rMax, height) {
      const points = [];
      points.push(new THREE.Vector2(rMin, -height / 2));
      points.push(new THREE.Vector2(rMax, -height / 2));
      points.push(new THREE.Vector2(rMax, height / 2));
      points.push(new THREE.Vector2(rMin, height / 2));
      
      const geometry = new THREE.LatheGeometry(points, 48, 0, Math.PI * 2);
      return geometry;
    }

    function createHollowConeGeometry(rMin1, rMax1, rMin2, rMax2, height) {
      // Create a hollow truncated cone using LatheGeometry
      // Bottom (z = -height/2): rMin1 (inner), rMax1 (outer)
      // Top (z = +height/2): rMin2 (inner), rMax2 (outer)
      const points = [];
      
      // Create the profile for lathe - from bottom to top
      points.push(new THREE.Vector2(rMin1, -height / 2));  // Inner bottom
      points.push(new THREE.Vector2(rMax1, -height / 2));  // Outer bottom
      points.push(new THREE.Vector2(rMax2, height / 2));   // Outer top
      points.push(new THREE.Vector2(rMin2, height / 2));   // Inner top
      
      const geometry = new THREE.LatheGeometry(points, 48, 0, Math.PI * 2);
      return geometry;
    }

    function createMesh(name, p){
      let geom;
      
      switch(p.Type){
        case 'Group':
          // Group is just a container, create empty geometry
          geom = new THREE.BufferGeometry();
          break;
        case 'TsBox':
          geom = new THREE.BoxGeometry((p.HLX||10)*2, (p.HLZ||10)*2, (p.HLY||10)*2); 
          break;
        case 'TsCylinder':
          if (p.RMin && p.RMin > 0) {
            geom = createHollowCylinderGeometry(p.RMin, p.RMax||10, (p.HL||10)*2);
          } else {
            geom = new THREE.CylinderGeometry(p.RMax||10, p.RMax||10, (p.HL||10)*2, 48);
          }
          break;
        case 'TsSphere':
          geom = new THREE.SphereGeometry(p.RMax||10, 48, 32);
          break;
        case 'G4Cons':
          // Truncated cone (conical frustum)
          const rMin1 = p.RMin1 || 0;
          const rMax1 = p.RMax1 || 10;
          const rMin2 = p.RMin2 || 0;
          const rMax2 = p.RMax2 || 10;
          const height = (p.HL || 10) * 2;
          
          if (rMin1 > 0 || rMin2 > 0) {
            // Hollow cone - create custom geometry
            geom = createHollowConeGeometry(rMin1, rMax1, rMin2, rMax2, height);
          } else {
            // Solid cone
            geom = new THREE.CylinderGeometry(rMax2, rMax1, height, 48);
          }
          break;
        default:
          geom = new THREE.BoxGeometry(10,10,10);
      }
      
      // Determine color: prioritize component Color property, then material color
      let meshColor;
      if (p.Color) {
        meshColor = colorNameToHex(p.Color);
      } else {
        const matData = materials[p.Material] || materials['Default'];
        meshColor = matData.color;
      }
      
      const mat = new THREE.MeshPhongMaterial({ 
        color: meshColor, 
        transparent: true, 
        opacity: currentOpacity,
        wireframe: wireframeMode,
        side: THREE.DoubleSide
      });
      
      // Don't create a mesh for Group types - just use the object as a container
      let mesh;
      if (p.Type === 'Group') {
        mesh = new THREE.Object3D();
      } else {
        mesh = new THREE.Mesh(geom, mat);
      }
      
      mesh.name = name;
      mesh.position.set(p.TransX||0, p.TransZ||0, p.TransY||0);
      
      if (p.RotX!=null) mesh.rotation.x = p.RotX;
      if (p.RotY!=null) mesh.rotation.z = p.RotY;
      if (p.RotZ!=null) mesh.rotation.y = p.RotZ;
      
      return mesh;
    }

    function buildHierarchy(geom) {
      const meshes = {};
      const roots = [];
      
      Object.entries(geom).forEach(([name, p]) => {
        meshes[name] = createMesh(name, p);
      });
      
      Object.entries(geom).forEach(([name, p]) => {
        if (p.Parent && meshes[p.Parent]) {
          meshes[p.Parent].add(meshes[name]);
        } else if (name !== 'World') {
          roots.push(meshes[name]);
        }
      });
      
      if (meshes['World']) {
        roots.push(meshes['World']);
      }
      
      return { meshes, roots };
    }

    function populateScene(result){
      for (let i=geometryGroup.children.length-1;i>=0;i--){ 
        geometryGroup.remove(geometryGroup.children[i]); 
      }
      
      parsedGeometry = result.geometry;
      const { meshes, roots } = buildHierarchy(parsedGeometry);
      
      roots.forEach(root => geometryGroup.add(root));
      
      const warnings = [...result.warnings];
      checkHierarchyOverlaps(parsedGeometry, meshes, warnings);
      
      applyWireframe();
      fitToView();
      
      return { warnings, errors: result.errors };
    }

    function renderWarnings(warns, errs){
      const el = document.getElementById('warnings');
      el.innerHTML = '';
      
      if (errs.length===0 && warns.length===0){ 
        el.innerHTML = `<span class="pill ok">✓ Geometry looks good</span>`; 
        return; 
      }
      
      errs.forEach(e=>{
        const d=document.createElement('div'); 
        d.className='logline'; 
        d.style.borderColor='rgba(244,67,54,.35)'; 
        d.innerHTML = `⚠ <span>${e}</span>`; 
        el.appendChild(d); 
      });
      
      warns.forEach(w=>{
        const d=document.createElement('div'); 
        d.className='logline'; 
        d.style.borderColor='rgba(255,152,0,.35)'; 
        d.innerHTML = `⚠ <span>${w}</span>`; 
        el.appendChild(d); 
      });
    }

    function fitToView(){
      if (geometryGroup.children.length===0) return;
      const box = new THREE.Box3().setFromObject(geometryGroup);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const dist = maxDim * 1.75 + 1;
      
      camera.position.set(center.x + dist, center.y + dist*0.8, center.z + dist);
      controls.target.copy(center); 
      controls.update();
    }

    function setNamedView(name){
      const box = new THREE.Box3().setFromObject(geometryGroup);
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());
      const d = Math.max(size.x, size.y, size.z) * 1.4 + 1;
      
      if (name==='top') camera.position.set(center.x, center.y + d, center.z);
      else if (name==='front') camera.position.set(center.x, center.y, center.z + d);
      else if (name==='right') camera.position.set(center.x + d, center.y, center.z);
      else camera.position.set(center.x + d, center.y + d*0.8, center.z + d);
      
      controls.target.copy(center); 
      controls.update();
    }

    function applyWireframe(){ 
      geometryGroup.traverse(o=>{
        if (o.isMesh){ 
          o.material.wireframe = wireframeMode; 
          o.material.opacity = currentOpacity; 
          o.material.needsUpdate = true; 
        } 
      }); 
    }

    function debounce(fn, ms){ 
      let t; 
      return (...args)=>{
        clearTimeout(t); 
        t=setTimeout(()=>fn.apply(null,args), ms); 
      }; 
    }

    function updateGeometry(){
      const text = editor.getValue();
      const result = parseTopasGeometry(text);
      const sceneResult = populateScene(result);
      renderWarnings(sceneResult.warnings, sceneResult.errors);
    }

    window.addEventListener('load', ()=>{
      initThree();
      initEditor();
      updateGeometry();
      
      document.getElementById('btnUpdate').onclick = updateGeometry;
      document.getElementById('btnFit').onclick = fitToView;
      document.getElementById('btnReset').onclick = ()=>{ 
        camera.position.set(300,240,300); 
        controls.target.set(0,0,0); 
        controls.update();
      };
      document.getElementById('btnWire').onclick = ()=>{ 
        wireframeMode=!wireframeMode; 
        applyWireframe(); 
      };
      document.getElementById('btnAxes').onclick = ()=>{ 
        showAxes=!showAxes; 
        axesHelper.visible=showAxes; 
      };
      document.getElementById('opacity').oninput = (e)=>{ 
        currentOpacity = parseFloat(e.target.value); 
        applyWireframe(); 
      };
      
      document.querySelectorAll('.controls [data-view]').forEach(btn=>
        btn.addEventListener('click', ()=> setNamedView(btn.getAttribute('data-view')))
      );
    });
  </script>
</body>
</html>
